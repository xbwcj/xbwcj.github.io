<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机系统概述（一）</title>
      <link href="2021/03/20/ji-suan-ji-xi-tong-gai-shu-yi/"/>
      <url>2021/03/20/ji-suan-ji-xi-tong-gai-shu-yi/</url>
      
        <content type="html"><![CDATA[<h1>操作系统的基本概念</h1><h2 id="什么是操作系统？"><a class="header-anchor" href="#什么是操作系统？">¶</a>什么是操作系统？</h2><p>  操作系统（Operating System， OS）是指：控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便的接口和环境的程序集合。<strong>操作系统是计算机系统中最基本的系统软件</strong>。<br>  其作用简单来说：<br>（1）控制和管理整个计算机系统的硬件与软件资源。<br>（2）组织和调度计算机工作和资源的分配。<br>（3）提供给用户和其他软件方便的接口和环境。</p><h2 id="操作系统的特征"><a class="header-anchor" href="#操作系统的特征">¶</a>操作系统的特征</h2><p>  操作系统是一种系统软件，其基本特征包括<strong>并发、共享、虚拟和异步</strong>。</p><h3 id="（1）并发（Concurrence）"><a class="header-anchor" href="#（1）并发（Concurrence）">¶</a>（1）并发（Concurrence）</h3><p>  并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序。因此我们可以认为它有上述的作用（2）.同时在整个操作系统中，我们引入进程的目的，也是为了使程序能并发执行。<br>  在上面我们需要注意的是，并发和并行的区别，通俗来说，并发是指事情同一时间段内发生，例如在我写这篇博客的整个时间段内，我顺便去偷看了旁边几个漂亮的妹纸，在宏观上来说，这些事情都是在这个时间段上是同时发生的，但是在微观上的其中几分钟，几秒钟来说，这些事情其实是交替发生的，整个过程大致就是“写博客-看妹纸-写博客-看妹纸-看妹纸-写博客”（不好意思，其实我只看了一次😇😇😇）而并行是指在同一时刻发生的，例如在我偷看妹纸的时候，发现我对面的哥们（经典无中生友😂😂😂）其实也在和我一样，不过他在偷看旁边的男生😳😳😳，那么我们两个人在相同的时刻做的这件事情，这就叫做并行。<br>  在我们进行提到的多线程中，如果你的电脑为单核CPU，那么即使你加再多的线程，也是并发执行，因为一个核心，只能处理一个任务。一个核心处理多任务的方法，（1）排队，一个一个执行。（2）一个执行一小段时间，在多个任务间切换，没有被服务的任务只能等待，表现就是你的电脑会有些卡顿。如果你的CPU有两个核心，那么它的每个核心，在此时此刻，可以分别服务一个任务，这样就可以实现并行。</p><h3 id="（2）共享（Sharing）"><a class="header-anchor" href="#（2）共享（Sharing）">¶</a>（2）共享（Sharing）</h3><p>  即资源共享，是指操作系统中的资源可供内存中多个并发执行的进程共同使用。共享主要分为<strong>互斥共享方式</strong>和<strong>同时访问方式</strong>。</p><h4 id="互斥共享方式"><a class="header-anchor" href="#互斥共享方式">¶</a>互斥共享方式</h4><p>  操作系统中的资源虽然可以同时提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。<br>  举一个通俗的例子来解释，如果有一个妹纸问我有没有时间陪她出去玩，但是同时我的平时一个很讨厌的人也在问我能否陪他出去，这两个进程同时请求使用我嘴的资源，这时我不可能同时回答他们两个人的问题，是或者不是都会让其中一个人误会我的意思（当然是想和妹纸出去，拒绝另外一个人）。这就是互斥共享。<br>  我们把上述的资源共享方式称为互斥共享，把一段时间内只允许一个进程访问的资源称为<strong>临界资源</strong>或者<strong>独占资源</strong>，例如：打印机、磁带机等。</p><h4 id="同时访问方式"><a class="header-anchor" href="#同时访问方式">¶</a>同时访问方式</h4><p>  允许一个时间段内由多个进程“同时”对他们进行访问<br>  “同时”通常上是宏观的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。比如说：今天在图书馆的这一个下午，看妹纸和写博客这两件事情都可以向我的眼睛和大脑来发送请求，使用这两个资源，在这段时间内，我可以看一眼妹子，然后写几行博客，交替进行这两个进程。在计算机中可供多个进程“同时”访问的典型资源是磁盘设备。<br>  互斥共享要求一种资源在一段时间内（哪怕是一段很小的时间）只能，满足一个请求，否则就会出现严重的问题（例如打字机一行打印A文档内容，一行打印B文档内容）而同时访问共享通常要求一个请求分几个时间片段间隔地完成。<br>  并发和共享之间互为存在的条件：<strong>（1）资源共享是以程序的并发为条件的，若系统不允许程序并发执行则不存在资源共享的问题。（2）若系统不能对资源共享实施有效的管理，则影响到程序的并发执行，甚至根本无法存在并发执行</strong>。</p><h3 id="（3）虚拟（Virtual）"><a class="header-anchor" href="#（3）虚拟（Virtual）">¶</a>（3）虚拟（Virtual）</h3><p>  虚拟是指把一个物理上的实体转变为若干逻辑上的对应物。操作系统的虚拟技术可归纳为：<strong>（1）时分复用技术：处理器的分时共享</strong>。<strong>（2）空分复用技术：虚拟存储器</strong>。</p><h3 id="（4）异步（Asynchronism）"><a class="header-anchor" href="#（4）异步（Asynchronism）">¶</a>（4）异步（Asynchronism）</h3><p>  在多道程序环境中，允许多个程序并发执行，但由于资源优先，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进。</p><h2 id="操作系统的目标和功能"><a class="header-anchor" href="#操作系统的目标和功能">¶</a>操作系统的目标和功能</h2><p>  （1）为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：<strong>处理机管理、存储器管理、设备管理和文件管理</strong>。<br>  （2）为了方便用户使用操作系统，还必须向用户提供接口。<br>  （3）操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><h3 id="操作系统作为计算机系统资源的管理者"><a class="header-anchor" href="#操作系统作为计算机系统资源的管理者">¶</a>操作系统作为计算机系统资源的管理者</h3><h4 id="处理机管理"><a class="header-anchor" href="#处理机管理">¶</a>处理机管理</h4><p>  在多道程序环境下，<strong>处理机的分配和运行都以进程、线程为基本单位</strong>，因而对处理机的管理可归结为对进程的管理。因此进程何时创建、何时撒销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括<strong>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</strong></p><h4 id="存储器管理"><a class="header-anchor" href="#存储器管理">¶</a>存储器管理</h4><p>  存储器管理是为了给多道程序的运行提供良好的环境，方便用户用及提高内存的利用率，主要包括<strong>内存分配与回收、地址映射、内存保护与共享和内存扩充等功能</strong>。</p><h4 id="文件管理"><a class="header-anchor" href="#文件管理">¶</a>文件管理</h4><p>  计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统，文件管理包括<strong>文件存储空间的管理、目录管理及文件读写管理和保护等</strong>。</p><h4 id="设备管理"><a class="header-anchor" href="#设备管理">¶</a>设备管理</h4><p>  设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括<strong>缓冲管理、设备分配、设备处理和虚拟设备等功能</strong>。</p><h3 id="操作系统作为用户与计算机硬件系统之间的接口"><a class="header-anchor" href="#操作系统作为用户与计算机硬件系统之间的接口">¶</a>操作系统作为用户与计算机硬件系统之间的接口</h3><p>  为了方便用户对于计算机硬件的操作以及运行自己计算机上的程序，操作系统为用户提供了接口，接口分为两类，<strong>（1）命令接口，（2）程序接口</strong>。</p><h4 id="命令接口"><a class="header-anchor" href="#命令接口">¶</a>命令接口</h4><p>  命令接口的目的是，用户利用这些命令来组织和控制作业的执行。其分为<strong>联机命令接口</strong>和<strong>脱机命令接口</strong>。<br>  <strong>联机命令接口</strong>又称交互式命令接口，适用于分时或实时系统的接口，通常是用户在键盘通过控制台或者终端输入操作命令，操作系统的命令解释程序解释执行输入的命令后，完成功能后，将指挥权返回终端。<br>  <strong>脱机命令接口</strong>又称批处理命令接口，适用于批处理系统。用户不能直接干预作业的运行，而是事先用相应的作业控制命令以作业操作说明书的形式提交给操作系统，等待系统中命令解释器对作业进行逐条处理。</p><h4 id="程序接口（系统调用）"><a class="header-anchor" href="#程序接口（系统调用）">¶</a>程序接口（系统调用）</h4><p>  程序接口由一组系统调用命令(也称广义指令)组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务。如使用各种外部设备、申请分配和回收内内存及其他用程序接口实现的，当前最为流行的是图形用户界面(GUT),即图形接口。</p><h3 id="操作系统用作扩充机器"><a class="header-anchor" href="#操作系统用作扩充机器">¶</a>操作系统用作扩充机器</h3><p>  裸机没有任何软件支持，而我们实际中的计算机系统是若干层软件改造之后的，在裸机的外层，就是操作系统，这也不难理解为什么我们称其为硬件与用户之间的中介，因为其提供了大量的资源管理功能和方便用户的各种服务功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xbwcj的失败史</title>
      <link href="2021/03/19/xbwcj-de-shi-bai-shi/"/>
      <url>2021/03/19/xbwcj-de-shi-bai-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="分享一句话"><a class="header-anchor" href="#分享一句话">¶</a>分享一句话</h2><p><font face="微软雅黑" size="4">你我都是内卷背景下不起眼的尘埃，被时代的洪流裹挟向前。</font></p><h2 id="个人失败历史"><a class="header-anchor" href="#个人失败历史">¶</a>个人失败历史</h2><p>入学以来大一参加计算机设计大赛失败。😟<br>入学以后第一场考试以及后面无数考试失利。😩<br>大一参加校内数学建模新生杯惨败。😞<br>大一参加华中赛数学建模无功而返。😑<br>大一参加互联网+因特殊原因退出。😔<br>……<br>大二开始接触DataFountain竞赛，一直徘徊在复赛圈，与决赛无缘。<br>开始学习acm算法，在各种比赛中被吊打。<br>开始学习一些简单的开发，但是没有完整做出一款属于自己的开发的应用。<br>大二参加华为软件精英挑战赛，被数据漏洞坑害（参赛经验不足，获取比赛信息时效性低），赛区64强止步。<br>大二参加全国k-code程序设计大赛，止步21名，倒在决赛圈（前二十名）门口。<br>参加MathorCup成功参赛。<br>大二暑期建模培训最终选拔全校第七名，特殊原因被淘汰。<br>……<br>大三参加天池Redis数据库中间件挑战赛止步决赛。<br>……<br>还有很多自己以及以往的失败历史。</p><h2 id="未来准备参加的比赛"><a class="header-anchor" href="#未来准备参加的比赛">¶</a>未来准备参加的比赛</h2><p>美赛成绩未出<br>继续准备参加计算机设计大赛、华为软件精英挑战赛、等之类的其他比赛。</p><h2 id="xbwcj的数学建模比赛的准备"><a class="header-anchor" href="#xbwcj的数学建模比赛的准备">¶</a>xbwcj的数学建模比赛的准备</h2><p>1、提高自己的编程能力，编程能力的提升是在平时就要锻炼的，平时写代码的时候不要马虎应付，多看博客等其他网站上的一些常用算法与伪代码，最重要的是了解算法的思维，严谨的思维+超强的编程能力才能轻松应对数模中的编程。<br>2、强烈推荐去看司守奎的《数学建模算法与应用》这本书，学习上面的一些比较常见的算法，自己一定要手动实现一次，自己不手动实现，就很难理解里面的编程思维。<br>3、多去准备一些比较新的智能优化算法，推荐公众号：数学算法实验室、智能优化算法。尝试自己改进一些算法，将这些算法做成接口的形式，在使用时只需要传参就可以。准备一些可以做出精美图片的数据分析的软件，例如Oracle提供的Data Visualization Desktop的软件，也可以使用Office的PPT功能。熟练使用可以在比赛过程中省时省力。或者准备一些Matlab或者Python的作图代码，例如简单的条形图、折线图、雷达图等，或者高级点的词云之类的，也以接口的形式封装。<br>4、如何上手？一定一定要自己独自去完成一次数模的全部流程，了解每个步骤应该做什么如何去做。只有全部接触才能知道自己的优势以及劣势，了解自己应该找什么样的队友来取长补短。<br>5、暑期培训前的准备：2020年由于疫情的原因，选拔赛是以组队的形式直接做题来选拔。在暑期培训前无论是校赛还是校外的数模比赛中，都可以自己去找队友，因此最好在暑期选拔培训前就确定好自己的队友，尽早开始磨合，利用其他的数模比赛找到队伍的不足，这样可以在选拔赛中发挥的更好一些。校外的数模比赛建议参加：华中赛、泰迪杯、数维杯、深圳杯、亚太赛。（挑选其中几个即可）</p><h2 id="xbwcj的校外比赛经验"><a class="header-anchor" href="#xbwcj的校外比赛经验">¶</a>xbwcj的校外比赛经验</h2><p>推荐几个我经常浪荡的比赛网站：<br><a href="https://tianchi.aliyun.com/competition/gameList/activeList">天池</a>、<a href="https://competition.huaweicloud.com/competitions">华为云</a>、<br><a href="https://www.datafountain.cn/competitions">DataFountain</a>、<a href="https://www.kaggle.com/competitions">kaggle</a>、<br>这些比赛有奖金，并且你会学习到很多平时在课堂里面学不到的知识技能。刚开始得奖会比较难，因为这些比赛中参加的不只是本科生，一般是面向所有在校学生，而且硕士生所占比例不低，所以开始大家可以去涨经验，后面能到何种地步就看大家自己的发挥了。🐶🐶🐶<br>如果想要提高自己的编程能力：<br><a href="https://ac.nowcoder.com/acm/problem/list">牛客</a>、<a href="https://www.luogu.com.cn/problem/list">洛谷</a>、<a href="http://acm.hdu.edu.cn/">hduOJ</a>、<a href="https://codeforces.com/problemset">CodeForces</a>、<a href="https://nanti.jisuanke.com/acm">计蒜客</a>。<br>去刷里面的题目，如果不是专门去训练acm，不需要去做太难的，达到中等就可以应付绝大多数公司的绝大多数笔试题了。也可以帮助你了解比较重要的基础算法。</p><h2 id="xbwcj个人大学总结经验（其实是自己的不足与后悔之处）"><a class="header-anchor" href="#xbwcj个人大学总结经验（其实是自己的不足与后悔之处）">¶</a>xbwcj个人大学总结经验（其实是自己的不足与后悔之处）</h2><p>1、一定要尽早规划，自己以后是找工作还是要读研，读研的话，是准备考研，还是A、B保，如果保研自己还欠缺什么，尽早做打算。<br>2、精心，静心去做一件事，贪多嚼不烂。<br>3、无论做什么，基础一定要扎实。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xbwcj的失败史</title>
      <link href="2021/03/19/xbwcj-de-shi-bai-shi-he-ccr-de-guang-hui-sui-yue/"/>
      <url>2021/03/19/xbwcj-de-shi-bai-shi-he-ccr-de-guang-hui-sui-yue/</url>
      
        <content type="html"><![CDATA[<h1>XBW</h1><h2 id="分享一句话"><a class="header-anchor" href="#分享一句话">¶</a>分享一句话</h2><p><font face="微软雅黑" size="4">你我都是内卷背景下不起眼的尘埃，被时代的洪流裹挟向前。</font></p><h2 id="个人失败历史"><a class="header-anchor" href="#个人失败历史">¶</a>个人失败历史</h2><p>入学以来大一参加计算机设计大赛失败。😟<br>入学以后第一场考试以及后面无数考试失利。😩<br>大一参加校内数学建模新生杯惨败。😞<br>大一参加华中赛数学建模无功而返。😑<br>大一参加互联网+因特殊原因退出。😔<br>……<br>大二开始接触DataFountain竞赛，一直徘徊在复赛圈，与决赛无缘。<br>开始学习acm算法，在各种比赛中被吊打。<br>开始学习一些简单的开发，但是没有完整做出一款属于自己的开发的应用。<br>大二参加华为软件精英挑战赛，被数据漏洞坑害（参赛经验不足，获取比赛信息时效性低），赛区64强止步。<br>大二参加全国k-code程序设计大赛，止步21名，倒在决赛圈（前二十名）门口。<br>参加MathorCup成功参赛。<br>大二暑期建模培训最终选拔全校第七名，特殊原因被淘汰。<br>……<br>大三参加天池Redis数据库中间件挑战赛止步决赛。<br>……<br>还有很多自己以及以往的失败历史。</p><h2 id="未来准备参加的比赛"><a class="header-anchor" href="#未来准备参加的比赛">¶</a>未来准备参加的比赛</h2><p>美赛成绩未出<br>继续准备参加计算机设计大赛、华为软件精英挑战赛、等之类的其他比赛。</p><h2 id="xbwcj的数学建模比赛的准备"><a class="header-anchor" href="#xbwcj的数学建模比赛的准备">¶</a>xbwcj的数学建模比赛的准备</h2><p>1、提高自己的编程能力，编程能力的提升是在平时就要锻炼的，平时写代码的时候不要马虎应付，多看博客等其他网站上的一些常用算法与伪代码，最重要的是了解算法的思维，严谨的思维+超强的编程能力才能轻松应对数模中的编程。<br>2、强烈推荐去看司守奎的《数学建模算法与应用》这本书，学习上面的一些比较常见的算法，自己一定要手动实现一次，自己不手动实现，就很难理解里面的编程思维。<br>3、多去准备一些比较新的智能优化算法，推荐公众号：数学算法实验室、智能优化算法。尝试自己改进一些算法，将这些算法做成接口的形式，在使用时只需要传参就可以。准备一些可以做出精美图片的数据分析的软件，例如Oracle提供的Data Visualization Desktop的软件，也可以使用Office的PPT功能。熟练使用可以在比赛过程中省时省力。或者准备一些Matlab或者Python的作图代码，例如简单的条形图、折线图、雷达图等，或者高级点的词云之类的，也以接口的形式封装。<br>4、如何上手？一定一定要自己独自去完成一次数模的全部流程，了解每个步骤应该做什么如何去做。只有全部接触才能知道自己的优势以及劣势，了解自己应该找什么样的队友来取长补短。<br>5、暑期培训前的准备：2020年由于疫情的原因，选拔赛是以组队的形式直接做题来选拔。在暑期培训前无论是校赛还是校外的数模比赛中，都可以自己去找队友，因此最好在暑期选拔培训前就确定好自己的队友，尽早开始磨合，利用其他的数模比赛找到队伍的不足，这样可以在选拔赛中发挥的更好一些。校外的数模比赛建议参加：华中赛、泰迪杯、数维杯、深圳杯、亚太赛。（挑选其中几个即可）</p><h2 id="xbwcj的校外比赛经验"><a class="header-anchor" href="#xbwcj的校外比赛经验">¶</a>xbwcj的校外比赛经验</h2><p>推荐几个我经常浪荡的比赛网站：<br><a href="https://tianchi.aliyun.com/competition/gameList/activeList">天池</a>、<a href="https://competition.huaweicloud.com/competitions">华为云</a>、<br><a href="https://www.datafountain.cn/competitions">DataFountain</a>、<a href="https://www.kaggle.com/competitions">kaggle</a>、<br>这些比赛有奖金，并且你会学习到很多平时在课堂里面学不到的知识技能。刚开始得奖会比较难，因为这些比赛中参加的不只是本科生，一般是面向所有在校学生，而且硕士生所占比例不低，所以开始大家可以去涨经验，后面能到何种地步就看大家自己的发挥了。🐶🐶🐶<br>如果想要提高自己的编程能力：<br><a href="https://ac.nowcoder.com/acm/problem/list">牛客</a>、<a href="https://www.luogu.com.cn/problem/list">洛谷</a>、<a href="http://acm.hdu.edu.cn/">hduOJ</a>、<a href="https://codeforces.com/problemset">CodeForces</a>、<a href="https://nanti.jisuanke.com/acm">计蒜客</a>。<br>去刷里面的题目，如果不是专门去训练acm，不需要去做太难的，达到中等就可以应付绝大多数公司的绝大多数笔试题了。也可以帮助你了解比较重要的基础算法。</p><h2 id="xbwcj个人大学总结经验（其实是自己的不足与后悔之处）"><a class="header-anchor" href="#xbwcj个人大学总结经验（其实是自己的不足与后悔之处）">¶</a>xbwcj个人大学总结经验（其实是自己的不足与后悔之处）</h2><p>1、一定要尽早规划，自己以后是找工作还是要读研，读研的话，是准备考研，还是A、B保，如果保研自己还欠缺什么，尽早做打算。<br>2、精心，静心去做一件事，贪多嚼不烂。<br>3、无论做什么，基础一定要扎实。</p><h1>Terence</h1><h2 id="最近做的事"><a class="header-anchor" href="#最近做的事">¶</a>最近做的事</h2><ul><li><p>和好朋友一起参加  <code>DataWhale</code> 三月份的组队学习（推荐系统和区块链方面）</p></li><li><p>学习英语和编程</p></li><li><p>准备了解一下多模态这个领域，也顺便考虑一下自己以后的研究方向，准备读研也不得不面对这个问题，以后要做什么？</p></li></ul><p>就以这个 <code>以后要做什么？</code> 题简单跟大家分享下</p><h2 id="以后要做什么？"><a class="header-anchor" href="#以后要做什么？">¶</a>以后要做什么？</h2><p>留给我们的选择其实不多，读研 or 就业</p><p>读研</p><ul><li>绩点要稳住（大数据专业绝大部分专业必修都在前两年）走 A 保</li><li>比赛拿奖项走 B 保</li></ul><p>科研</p><ul><li>理论研究</li><li>数据挖掘</li><li>机器学习</li><li>NLP（自然语言处理）</li><li>CV（计算机视觉）</li><li>多模态</li></ul><p>职业</p><ul><li><p>数据科学家</p></li><li><p>数据分析师</p></li><li><p>算法工程师</p></li></ul><h2 id="参加的比赛"><a class="header-anchor" href="#参加的比赛">¶</a>参加的比赛</h2><ul><li>华中地区大学生数学建模邀请赛省赛</li><li>华为大学生ICT大赛湖北区域省赛</li><li>全国大学生数学建模省赛</li><li>美国大学生数学建模大赛国赛</li><li>全国大学生节能减排国赛</li><li>中国大学生计算机设计大赛国赛</li><li>中国大学生服务外包创新创业大赛国赛</li><li>Kaggle、天池、腾讯广告…</li></ul><h2 id="数学建模"><a class="header-anchor" href="#数学建模">¶</a>数学建模</h2><p>讲下数学建模，其实刚才雯雯也说了很多，也非常详细，跟我观点也蛮吻合的。有一个观点，就是在咱们学校成功进入校队，参加国赛和美赛，不是一件容易的事情。确实它收益很大，每一年都有很多同学通过数学建模成功保研。并不是很推荐大家去很功利地做一件事情，数模带给我们的不仅仅是一个保研的资格或者说门票，更多的是带来一种能力。</p><ul><li>分析问题，将实际问题建立数学模型的能力</li><li>解决问题，运用自己所学去求解模型的能力</li><li>撰写科技论文的能力</li><li>团队配合</li></ul><p>2019年数学建模选拔形式（具体细节可以在教务处官网查询）</p><ul><li><p>编程：开卷、不限语言（主要是 Matlab ）对 8 个题目进行求解，求解问题大多是线性方程、0-1背包、最优化、智能算法以及开放题。最终按成绩排名。</p></li><li><p>建模：这个我就不太清楚了</p></li></ul><h2 id="其他比赛"><a class="header-anchor" href="#其他比赛">¶</a>其他比赛</h2><ul><li><p>ACM</p></li><li><p><a href="http://i.whut.edu.cn/xxtg/znbm/jwc/202103/t20210317_484335.shtml">【教务处】关于组织参加 “2021 年（第14届）中国大学生计算机设计大赛”的通知</a></p></li><li><p><a href="http://i.whut.edu.cn/xxtg/znbm/jwc/202103/t20210304_483136.shtml">【教务处】关于组织参加第十二届中国大学生服务外包创新创业大赛的通知</a></p></li><li><p><a href="http://i.whut.edu.cn/xxtg/znbm/jwc/202103/t20210304_483133.shtml">【教务处】关于举办“2021年中国高校计算机大赛-团体程序设计天梯赛”校内选拔赛的通知</a></p></li></ul><p>怎么说，不断去接触去尝试才会有更多可能。你说比赛它难不难，要想拿到好名次确实很难，没有一帆风顺的路，当你觉得自己真的真的真的快撑不下去的时候，那就别撑了，我们又不是把伞，老撑着干嘛:happy:</p><h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2><p>找到自己喜欢的事情，然后坚持下去就好了。如果有一件事（限学业方面），能够让你忘记时间地投入进去，那就是足够热爱的事情啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--线性表</title>
      <link href="2021/03/08/shu-ju-jie-gou-xian-xing-biao/"/>
      <url>2021/03/08/shu-ju-jie-gou-xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是线性表？"><a class="header-anchor" href="#什么是线性表？">¶</a>什么是线性表？</h2><p>线性表（linear_list）是最常用且最简单的一种数据结构，一个线性表相当于是n个数据元素的有限序列，其中每个数据元素表示的内容在不同的情况下并不相同，有可能是一个数字、一个符号之类的。若将线性表用集合表示为:<br>$$<br>(a_{1}, …, a_{i-1}, a_{i}, a_{i+1}, …, a_{n})<br>$$</p><p>由集合中可以看出，除第一个外，集合中的每个数据元素均只有一个前驱，除最后一个外，集合中的每个数据元素均只有一个后继。</p><h2 id="线性表的两种表示形式"><a class="header-anchor" href="#线性表的两种表示形式">¶</a>线性表的两种表示形式</h2><p>（1）顺序表示：用一组地址连续的存储单元依次存储线性表的数据元素，称为线性表的顺序存储结构，可随机存取表中任一元素（其实就是数组）<br>（2）链式表示：用一组任意的存储单元存储线性表中的数据元素，称为线性表的链式存储结构。它的存储单元可以是连续的，也可以是不连续的。在表示数据元素之间的逻辑关系时，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置），这两部分信息组成数据元素的存储映像，称为结点（node）。它包括两个域；存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称为指针或链。<br>可以用下图来更加直观的表示顺序结构和链式结构</p><h2 id="线性表的一般定义"><a class="header-anchor" href="#线性表的一般定义">¶</a>线性表的一般定义</h2><p>线性表的抽象数据类型定义如下：<br>数据对象：$$D , = , {a_{i} , | , a_{i} , \in , ElemSet, ,i = 1,2,\cdots,n, , n \geq 0}$$<br>数据关系：$$R1 , = , {&lt; a_{i-1},a_{i} &gt; |a_{i-1},a{i} \in D,,i=2,\cdots,n}$$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ADT List &#123;    &#x2F;&#x2F;基本操作    InitList(&amp;L) &#x2F;&#x2F;构造空线性表L    DestoryList(&amp;L) &#x2F;&#x2F;销毁线性表L    ClearList(&amp;L) &#x2F;&#x2F;将线性表L变为空    ListEmpty(L) &#x2F;&#x2F;若线性表L为空表，返回TRUE，否则返回FASLSE    ListLength(L) &#x2F;&#x2F;返回线性表中的数据元素个数    GetElem(L, i, &amp;e) &#x2F;&#x2F;用e返回L中第i个数据元素的值    PriorElem(L, cur_e, &amp;pre_e) &#x2F;&#x2F; 如果cur_e是线性表中的元素，而且不是第一个，那么我们就可以返回该元素前一个元素的值    NextElem(L, cur_e, &amp;next_e) &#x2F;&#x2F; &#x2F;&#x2F;如果cur_e是线性表中的元素，而且不是最后一个，就返回它下一个元素的值    Listinsert(&amp;L, i, e)&#x2F;&#x2F;如果线性表存在了，而且i符合条件，则在i位置插入一个元素    ListDelete(&amp;L, i)&#x2F;&#x2F;删除i位置上的元素    ListDelete_data(&amp;L, e, order)&#x2F;&#x2F;删除指定的元素e，order决定是删除一个，还是全部。    Connect_two_List(L_a,L_b,&amp; L_c)&#x2F;&#x2F;连接两个线性表，除去重复的内容    print(L)&#x2F;&#x2F;打印线性表    &#x2F;*        此处省略部分其他常见的操作    *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述的函数中需要注意，如果要改变原本线性表的内容，则需要传入线性表的地址，如果只是对线性表进行查询等不改变原本的线性表内容的操作，则不需要以地址的形式传入。（这部分其实就是C/C++的对传入函数参数值改变的原理，在此做一个小的提醒）。</p><h2 id="顺序存储结构常见的结构体实现"><a class="header-anchor" href="#顺序存储结构常见的结构体实现">¶</a>顺序存储结构常见的结构体实现</h2><p>我们通过线性表顺序结构来实现线性表的一些基础操作。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;bits&#x2F;stdc++.h&gt;#define SIZE 100#define SIZE_T 150using namespace std;typedef int ElemType;struct List &#123;    ElemType *data; &#x2F;&#x2F;数据    int length; &#x2F;&#x2F;长度    int size; &#x2F;&#x2F;线性表初始容量&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序存储结构InitList-函数的实现"><a class="header-anchor" href="#顺序存储结构InitList-函数的实现">¶</a>顺序存储结构InitList()函数的实现</h2><p>线性表的顺序表示可以看作对数组进行一些操作，初始化函数就是将表的长度变为0，对data进行堆内存的分配和初始容量的初始化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;创建一个空的线性表void InitList(List &amp;newList) &#123;    &#x2F;&#x2F;初始容量为startsize    newList.size &#x3D; SIZE_T;    &#x2F;&#x2F;首先开辟空间    newList.data &#x3D; (int *)malloc(SIZE * sizeof(ElemType));    if(!newList.data)    &#123;        exit(OVERFLOW); &#x2F;&#x2F; 存储分配失败    &#125;    &#x2F;&#x2F;空表，长度是0    newList.length &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序存储结构DestoryList-函数的实现"><a class="header-anchor" href="#顺序存储结构DestoryList-函数的实现">¶</a>顺序存储结构DestoryList()函数的实现</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;前提是线性表已经存在void Destory (List &amp;newList)&#123;if (newList &#x3D;&#x3D; NULL)    &#123;        exit(OVERFLOW);&#x2F;&#x2F; 线性表不存在    &#125;    &#x2F;&#x2F;首先释放堆内存free(newList.data);    &#x2F;&#x2F;每次释放堆内存后，应将对应的指针指向NULL，这是一个比较好的编程习惯    newList.data &#x3D; NULL;    newList.length &#x3D; 0;    newList.size &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序存储结构ClearList-函数的实现"><a class="header-anchor" href="#顺序存储结构ClearList-函数的实现">¶</a>顺序存储结构ClearList()函数的实现</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;前提是线性表已经存在void ClearList(List &amp;newList) &#123;    if (newList &#x3D;&#x3D; NULL)    &#123;        exit(OVERFLOW);&#x2F;&#x2F; 线性表不存在    &#125;    newList.length &#x3D; 0;free(newList.data);    newList.data &#x3D; NULL;    &#x2F;&#x2F;重新开辟空间    newList.data &#x3D; (int *)malloc(SIZE * sizeof(ElemType));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/02/13/hello-world/"/>
      <url>2021/02/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BAS算法</title>
      <link href="2021/01/29/bas-suan-fa/"/>
      <url>2021/01/29/bas-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="天牛须搜索-Beetle-Antennae-Search-BAS"><a class="header-anchor" href="#天牛须搜索-Beetle-Antennae-Search-BAS">¶</a>天牛须搜索(Beetle Antennae Search-BAS)</h2><p>又称甲壳虫须搜索，类似于遗传算法、粒子群算法、模拟退火等智能优化算法，天牛须搜索不需要知道函数的具体形式，不需要梯度信息，就可以实现高效寻优。<br><strong>优点</strong>：相比于粒子群算法，天牛须搜索只需要一个个体，即一只天牛，运算量大大降低。</p><h2 id="仿生学原理"><a class="header-anchor" href="#仿生学原理">¶</a>仿生学原理</h2><p>天牛须搜索算法模仿自然界中天牛觅食行为。在天牛觅食过程中，其并不知道食物在哪里，但食物会产生特殊气味，吸引天牛向着食物前进。天牛通过其两只触角对空气中的食物气味进行感知，且根据食物距离两只触角的距离远近不同，两只触角所感知的气味浓度也有所差异。当食物处于天牛左侧时，左侧触角感知的气味浓度强于右侧触角感知的气味浓度，天牛根据两只触角所感知的浓度差，向着浓度强的一侧随机前进。通过一次次迭代，最终找到食物的位置。</p><h2 id="行为启发"><a class="header-anchor" href="#行为启发">¶</a>行为启发</h2><p>食物的气味就相当于一个函数,这个函数在三维空间每个点值都不同,天牛两个须可以采集自身附近两点的气味值,天牛的目的是找到仝局气味值最大的点仿照天牛的行为,我们就可以高效的进行函数寻优。</p><h2 id="算法模型"><a class="header-anchor" href="#算法模型">¶</a>算法模型</h2><p>BAS算法主要是通过在不停的左右触角气味浓度比对中前进，同其他算法相比，原理十分简单。<br>在进行两只触角气味浓度计算之前，需要对其进行一系列准备工作，在$D$维空间中天牛的位置为$X = (x_{1}, x_{2}, … , x_{n})$,天牛左右两只触角的位置被定义为如下公式所示模型：</p><p>$$<br>\left{ \begin{array}{l}<br>{X_r} = X + l * \mathop d\limits^ \to  \<br>{X_l} = X - l * \mathop d\limits^ \to<br>\end{array} \right.<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 智能优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和、二维前缀和与差分个人理解</title>
      <link href="2020/05/28/qian-zhui-he-er-wei-qian-zhui-he-yu-chai-fen-ge-ren-li-jie/"/>
      <url>2020/05/28/qian-zhui-he-er-wei-qian-zhui-he-yu-chai-fen-ge-ren-li-jie/</url>
      
        <content type="html"><![CDATA[<h1>前缀和</h1><h2 id="什么是前缀和"><a class="header-anchor" href="#什么是前缀和">¶</a>什么是前缀和</h2><p>  前缀和顾名思义就是指一个数组的某一个下标的（包括该下标）之前的所有数组元素的和。现在我们假设有某一数组a = [1, 2, 3, 4, 5, 6, 7, 8, 9]。其前缀和数组为sum，那么sum数组与a数组对应的关系如下图所示。<br><img src="/2020/05/28/qian-zhui-he-er-wei-qian-zhui-he-yu-chai-fen-ge-ren-li-jie/1.png" alt="在这里插入图片描述"><br>  由上面的对应关系我们可以得到他们满足如下的公式。</p><p><img src="/2020/05/28/qian-zhui-he-er-wei-qian-zhui-he-yu-chai-fen-ge-ren-li-jie/2.png" alt="在这里插入图片描述"><br>  以上的公式即为<strong>一维前缀和</strong>一维前缀和的代码模板如下所示。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;**     * 一维前缀和     *     * @a 表示原数组     * @sum 表示a数组的一维前缀和     *&#x2F;     const int maxn &#x3D; 1e5 + 10;     int a[9] &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;      int sum[maxn];    void oneDimen(int num) &#123;&#x2F;&#x2F;num表示数组a的长度        sum[0] &#x3D; a[0];        for (int i &#x3D; 1; i &lt; num; i++) &#123;            sum[i] &#x3D; sum[i - 1] + a[i];        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前缀和使用情况"><a class="header-anchor" href="#前缀和使用情况">¶</a>前缀和使用情况</h2><p>  我们在做题的时候经常会遇到查询问题，例如给出一个数组a，再给出m次查询，每次查询都会给出两个数L，R，分表表示查询区间的左右范围。如果我们只是使用最简单的朴素查询的方法，每次遍历区间，进行m次的查询，这样在题目所给数据范围较小的情况下可以进行，但是当查询次数很大时，其时间复杂度为<strong>O（n*m）<strong>会使运行TLE，所以我们使用上述的前缀和可以使时间复杂度降低为</strong>O(m+n)</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int query(int L, int R)&#123;retrun sum[R] - sum[L - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1>差分</h1><h2 id="什么是差分"><a class="header-anchor" href="#什么是差分">¶</a>什么是差分</h2><p>  差分就是指相邻两个数的差，我们假设存在一个数组，如下图所示<br><img src="/2020/05/28/qian-zhui-he-er-wei-qian-zhui-he-yu-chai-fen-ge-ren-li-jie/3.png" alt="在这里插入图片描述"><br>  具体代码模板如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int maxn &#x3D; 1e5 + 10;int a[9] &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int diff[maxn];&#x2F;&#x2F;求出差分数组void chafen(int num)&#123;&#x2F;&#x2F;num表示原数组的长度diff[0] &#x3D; a[0];for(int i &#x3D; 1; i &lt; num; i++)&#123;diff[i] &#x3D; a[i] - a[i - 1];&#125;&#125;&#x2F;&#x2F;对区间进行加操作void addarray(int L, int R, int k)&#123;&#x2F;&#x2F;L和R分别代表对加区间的左右范围，k表示在区间里每个元素加的数字diff[L] +&#x3D; k;diff[R + 1] -&#x3D; k;&#x2F;&#x2F;这里特别要注意，因为在前面进行区间加后，后面一个数与前面这个数的差变小了，所以要在后面这个数的差分数组减去前面区间所增加的数字。&#125;&#x2F;&#x2F;通过差分数组和原数组a推理得到进行区间加后数组中某一个元素的值void get_a()&#123;for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;a[i] &#x3D; doff[i] + a[i - 1];&#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="差分使用情况"><a class="header-anchor" href="#差分使用情况">¶</a>差分使用情况</h2><p>  区间加：把数组a[l]到a[r]都加上k，这种操作称为区间加。在进行区间加的操作后得到的数组b，我们对数组b进行查询，但可以发现如果是L——-R非常大的情况下，通过朴素的区间范围内主次累加求和这个操作执行的次数又很多，那时间复杂度会很高。所以可以使用差分的思想来降低复杂度。</p><h1>二维前缀和</h1><h2 id="什么是二维前缀和"><a class="header-anchor" href="#什么是二维前缀和">¶</a>什么是二维前缀和</h2><p><img src="/2020/05/28/qian-zhui-he-er-wei-qian-zhui-he-yu-chai-fen-ge-ren-li-jie/4.png" alt="在这里插入图片描述"><br>  在上图中深蓝色的部分代表的是二维数组的索引，浅蓝色的部分代表的是二维数组的每个元素的值。其二维前缀和如下图所示<br><img src="/2020/05/28/qian-zhui-he-er-wei-qian-zhui-he-yu-chai-fen-ge-ren-li-jie/5.png" alt="在这里插入图片描述"><br>  前缀和数组里每一个位置都表示原数组当前索引左上方的数字的和。<br>如上表中的而为前缀和数组：prefixSum[3, 3] = src[0~2, 0~2]的和;<br>二维前缀和数组的计算步骤如下所示。<br>可以分为四种情况</p><ol><li>i == 0 &amp;&amp; j ==0，只有一个直接赋值即可：prefixSum[0, 0] = a[0, 0]。</li><li>i == 0，最左边的一列，二维前缀和为元素上一行相同列的元素加该数字，公式为prefixSum[0, j] = prefixSum[0, j-1] + a[0, j]；</li><li>j == 0，最上面一排，与i == 0类似prefixSum[i, o] = prefixSum[i-1, 0] + a[i, 0];</li><li>i!=0 || j!=0，其公式为 prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] + a[i][j] - prefixSum[i - 1][j - 1];<br>其代码模板如下所示</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;** * 二维前缀和 * * @param src 原数组 * @return 二维前缀和 *&#x2F; const int maxn &#x3D; 100; int prefixSum[maxn][maxn];void twoDimen(int a[][], int n, int m) &#123;&#x2F;&#x2F;n和m分别代表二维原始数组的行列长度    for (int i &#x3D; 0; i &lt; n; i++) &#123;        for (int j &#x3D; 0; j &lt; m; j++) &#123;            if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;第0个，最左上角                prefixSum[i][j] &#x3D; a[i][j];            &#125; else if (i &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;第一行，最顶部一行                prefixSum[i][j] &#x3D; prefixSum[i][j - 1] + a[i][j];            &#125; else if (j &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;第一列，最左边一列                prefixSum[i][j] &#x3D; prefixSum[i - 1][j] + a[i][j];            &#125; else &#123;&#x2F;&#x2F;其他                prefixSum[i][j] &#x3D; prefixSum[i - 1][j] + prefixSum[i][j - 1] + a[i][j] - prefixSum[i - 1][j - 1];            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二维前缀和的使用情况"><a class="header-anchor" href="#二维前缀和的使用情况">¶</a>二维前缀和的使用情况</h2><p>  一般使用二维前缀和可以求子矩阵的最大值。通过求解出整个矩阵的二维前缀和数组，然后对二位前缀和数组中的元素进行查询，找到其和最大的子矩阵。</p><h2 id="二维前缀和的差分"><a class="header-anchor" href="#二维前缀和的差分">¶</a>二维前缀和的差分</h2><p>  二维前缀和也可以使用差分的形式。方法是和一维类似的，我们也是需要另开一个数组记录修改操作，最后求前缀和时统计修改操作，只是二维每一次操作需要记录4个位置，一维只需要记录2个位置。具体模板代码如下所示。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void chafen()&#123;for(int i&#x3D;0;i&lt;m;i++)&#123;&#x2F;&#x2F;m是修改操作次数 int x1,y1,x2,y2,p;cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;p;b[x1][y1]+&#x3D;p;b[x2+1][y2+1]+&#x3D;p;b[x2+1][y1]-&#x3D;p;b[x1][y2+1]-&#x3D;p;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  以上部分来自个人理解以及从其他大佬的博客中领悟到的，有些内容可能与其他大佬相似，如有侵权，请及时指出，立马进行修正。有写的不好地方也请及时指出，本人菜鸡，勿喷。</p><p><font face="微软雅黑" size="4">你我都是内卷背景下不起眼的尘埃，被时代的洪流裹挟向前。</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树个人理解</title>
      <link href="2020/05/27/xian-duan-shu-ge-ren-li-jie/"/>
      <url>2020/05/27/xian-duan-shu-ge-ren-li-jie/</url>
      
        <content type="html"><![CDATA[<h1>线段树</h1><p><img src="/2020/05/27/xian-duan-shu-ge-ren-li-jie/1.png" alt="在这里插入图片描述"></p><h2 id="定义："><a class="header-anchor" href="#定义：">¶</a>定义：</h2><p>  线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。</p><h2 id="作用范围："><a class="header-anchor" href="#作用范围：">¶</a>作用范围：</h2><p>  线段树的适用范围很广，可以在线维护修改以及查询区间上的最值，求和。更可以扩充到二维线段树（矩阵树）和三维线段树（空间树）。对于一维线段树来说，每次更新以及查询的时间复杂度为O(logN)。还支持区间修改，单点修改等操作。</p><h2 id="实现原理："><a class="header-anchor" href="#实现原理：">¶</a>实现原理：</h2><p>  线段树主要是把一段大区间平均地划分成两段小区间进行维护，再用小区间的值来更新大区间。这样既能保证正确性，又能使时间保持在log级别（因为这棵线段树是平衡的）。也就是说，一个[L…R]的区间会被划分成[L…(L+R)/2]和[(L+R)/2+1…R]这两个小区间进行维护，直到L=R。但是在上述的过程中我们会遇到以下几个问题，就是我们该如何建树，建树的过程中每一个下标我们该如何去分配，分派到的每一个空间我们应该用来存放哪些数据。</p><p><img src="/2020/05/27/xian-duan-shu-ge-ren-li-jie/2.png" alt="在这幅图片中"><br>  在这里我们仅对线段树中常见的区间最大值问题进行解释讨论。假设所给的区间为F[1:6] = {1, 9, 7, 8, 2, 3}。那么其对应的线段树的结构就如上图所示。其中红色的圆圈就代表线段树对应的每一个结点的下标。蓝色方框中的Max就是我们每一个结点所存放的内容，即每一个区间存放的最大值。Max下面的内容是对这个区间范围的一个说明，并不需要存放在数组中。<br>  仔细看这幅图我们会发现，其中结点的下标并不连续（在图中结点的标号并没有10，11）。这是因为我们在用数组对线段树进行模拟的时候，必须要提前对整个树的空间进行提前的开辟，所开辟的空间虽然并没有使用到，但是其仍然真是存在，这也是为什么我们在对数组进行开辟空间时一般会选择4<em>n的大小以避免出现RE。<br>  通过观察上面的线段树结点标号我们可以发现，对于一个区间[L,R]来说，最重要的数据当然就是区间的左右端点L和R，但是大部分的情况我们并不会去存储这两个数值，而是通过递归的传参方式进行传递。这种方式用指针好实现，定义两个左右子树递归即可，按时指针表示过于繁琐，而且不方便各种操作，大部分的线段树都是使用数组进行表示，那这里怎么快速使用下标找到左右子树呢。这就会涉及到每个结点下表数字的规律。我们发现在线段树中每个非叶子结点的度都为2，且父亲节点的左右两个孩子分别存储父亲一半的区间，而每个父亲结点存放的欧式孩子的最大值，而且左孩子的下标都为偶数，右孩子的下标都是奇数且左孩子下标数+1，即：<br><strong><em><em>L = Father</em>2 （左子树下标为父亲下标的两倍）<br>R = Father</em>2+1（右子树下标为父亲下标的两倍+1）</strong></em>*<br>或<br><strong>k&lt;&lt;1（结点k的左子树下标）<br>k&lt;&lt;1|1（结点k的右子树下标）</strong><br>所以建树的操作可用如下代码实现</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int maxn &#x3D; 1e5+5;const int INF &#x3D; 0x3f3f3f3f;int tree[maxn&lt;&lt;2],temp[maxn];&#x2F;&#x2F;tree[]数组表示线段树数组，temp[]表示存放原始数据的数组void Build(int l,int r,int rt)&#123; &#x2F;&#x2F;l,r表示当前节点区间，rt表示当前节点编号      if(l&#x3D;&#x3D;r) &#123;&#x2F;&#x2F;若到达叶节点，即区间的左右值相等           tree[rt]&#x3D;temp[l];&#x2F;&#x2F;储存数组值           return;      &#125;      int mid &#x3D; (l+r)&gt;&gt;1;  &#x2F;&#x2F;mid表示中间点    &#x2F;&#x2F;左右递归       Build(l,mid,rt&lt;&lt;1);      Build(mid+1,r,rt&lt;&lt;1|1);      tree[rt] &#x3D; max(tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1];&#x2F;&#x2F;更新信息&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线段树的基本操作："><a class="header-anchor" href="#线段树的基本操作：">¶</a>线段树的基本操作：</h2><h3 id="一、点更新"><a class="header-anchor" href="#一、点更新">¶</a>一、点更新</h3><p><img src="/2020/05/27/xian-duan-shu-ge-ren-li-jie/3.png" alt="在这里插入图片描述"><br>  假设我们将上述的区间F[1:6] = {1, 9, 7, 8, 2, 3}中的F[3] = 7通过对其+3更改为10。那么我们应当对线段树进行如下的几个操作。</p><ol><li>我们通过线段树的根结点向下遍历，通过叶子结点所在的区间进行查询，在每一处根结点与我们改变的值相比较，如果F[3] = 10大于当前根结点中存储的Max值，那么将Max = 10，否则不变且继续向下遍历。</li><li>直至到L=R时，即为我们改变的叶子结点，将其中存储的值变为我们上述的F[3] = 10，退出。<br>  具体代码实现如下：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;递归方式更新 updata(p,v,1,n,1);void updata(int p,int v,int l,int r,int rt)&#123;    &#x2F;&#x2F;p为下标，v为要加上的值，l，r为结点区间，rt为结点下标    if(l &#x3D;&#x3D; r)&#123;    &#x2F;&#x2F;左端点等于右端点，即为叶子结点，直接加上v即可        temp[rt] +&#x3D; v;        tree[rt] +&#x3D; v;    &#x2F;&#x2F;原数组和线段树数组都得到更新        return ;    &#125;    int m &#x3D; l + ((r-l)&gt;&gt;1);    &#x2F;&#x2F;m则为中间点，左儿子的结点区间为[l,m],右儿子的结点区间为[m+1,r]    if(p &lt;&#x3D; m)    &#x2F;&#x2F;如果需要更新的结点在左子树区间        updata(p,v,l,m,rt&lt;&lt;1);    else    &#x2F;&#x2F;如果需要更新的结点在右子树区间        updata(p,v,m+1,r,rt&lt;&lt;1|1);    tree[rt] &#x3D; max(tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1];    &#x2F;&#x2F;更新父节点的值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、区间查询"><a class="header-anchor" href="#二、区间查询">¶</a>二、区间查询</h3><p>  线段树的每个结点存储的都是一段区间的信息 ，这就意味着如果我们刚好要查询这个区间，那么则直接返回这个结点的信息即可，比如对于上面线段树，如果我直接查询[1,6]这个区间的最值，那么直接返回根节点信息10即可，查询[1,2]直接返回9。但是有时题目中为了设置难度并不会轻易让我们查询每个结点所表示的区间。比如现在我要查询[2,5]区间的最值，这时候我们会发现并不存在某个节点的区间是[2,5]，那么这时我们应该采取一些什么方法来进行区间信息的查询呢？<br><img src="/2020/05/27/xian-duan-shu-ge-ren-li-jie/4.png" alt="在这里插入图片描述"></p><ol><li>首先我们发现区间[2,5]在线段树中包括的节点有[2,2]，[3,3]，[4,4]，[5,5]，[4,5]。但是[4,4]，[5,5]这两个信息的区间已经被[4,5]区间所包含，所以我们真正需要查询的结点为[2,2]，[3,3]，[4,5]这三个区间所在的结点。</li><li>其次从根节点开始往下递归，如果当前结点是要查询的区间的真子集，则返回这个结点的信息且不需要再往下递归。<br>  具体代码如下</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;递归方式区间查询 query(Ld,Rd,1,n,1);int query(int Ld,int Rd,int l,int r,int rt)&#123;    &#x2F;&#x2F;[Ld,Rd]即为要查询的区间，l，r为结点区间，rt为结点下标    if(Ld &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; Rd)    &#x2F;&#x2F;如果当前结点的区间真包含于要查询的区间内，则返回结点信息且不需要往下递归        return tree[rt];    int ans &#x3D; -INF;    &#x2F;&#x2F;返回值变量，根据具体线段树查询的什么而自定义    int mid &#x3D; (l+r)&gt;&gt;1;    &#x2F;&#x2F;m则为中间点，左儿子的结点区间为[l,m],右儿子的结点区间为[m+1,r]    if(Ld &lt;&#x3D; m)    &#x2F;&#x2F;如果左子树和需要查询的区间交集非空        ans &#x3D; max(ans, query(L,R,l,m,k&lt;&lt;1));    if(Rd &gt; m)    &#x2F;&#x2F;如果右子树和需要查询的区间交集非空，注意这里不是else if，因为查询区间可能同时和左右区间都有交集        ans &#x3D; max(ans, query(L,R,m+1,r,k&lt;&lt;1|1));    return ans;    &#x2F;&#x2F;返回当前结点得到的信息    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、区间更新"><a class="header-anchor" href="#三、区间更新">¶</a>三、区间更新</h3><p>  在线段树的区间更新中我们引进了一个新的思想，Lazy_tag，字面意思就是懒惰标记的意思，实际上它的功能也就是偷懒= =，因为对于一个区间[L,R]来说，我们每次都更新区间中的每一个值，那样的话更新的复杂度将会是O(NlogN)，这太高了，所以引进了Lazy_tag，这个标记一般用于处理线段树的区间更新。<br>　　线段树在进行区间更新的时候，为了提高更新的效率，所以每次更新只更新到更新区间完全覆盖线段树结点区间为止，这样就会导致被更新结点的子孙结点的区间得不到需要更新的信息，所以在被更新结点上打上一个标记，称为lazy-tag，等到下次访问这个结点的子结点时再将这个标记传递给子结点，所以也可以叫延迟标记。<br>　　也就是说递归更新的过程，更新到结点区间为需要更新的区间的真子集不再往下更新，下次若是遇到需要用这下面的结点的信息，再去更新这些结点，所以这样的话使得区间更新的操作和区间查询类似，复杂度为O(logN)。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void Pushdown(int rt)&#123;    &#x2F;&#x2F;更新子树的lazy值，这里是RMQ的函数，要实现区间和等则需要修改函数内容    if(lazy[rt])&#123;    &#x2F;&#x2F;如果有lazy标记        lazy[rt&lt;&lt;1] +&#x3D; lazy[rt];    &#x2F;&#x2F;更新左子树的lazy值        lazy[rt&lt;&lt;1|1] +&#x3D; lazy[rt];    &#x2F;&#x2F;更新右子树的lazy值        t[rt&lt;&lt;1] +&#x3D; lazy[rt];        &#x2F;&#x2F;左子树的最值加上lazy值        t[rt&lt;&lt;1|1] +&#x3D; lazy[rt];    &#x2F;&#x2F;右子树的最值加上lazy值        lazy[rt] &#x3D; 0;    &#x2F;&#x2F;lazy值归0    &#125;&#125;&#x2F;&#x2F;递归更新区间 updata(L,R,v,1,n,1);void updata(int Ld,int Rd,int v,int l,int r,int rt)&#123;    &#x2F;&#x2F;[Ld,Rd]即为要更新的区间，l，r为结点区间，k为结点下标    if(Ld &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; Rd)&#123;    &#x2F;&#x2F;如果当前结点的区间真包含于要更新的区间内        lazy[rt] +&#x3D; v;    &#x2F;&#x2F;懒惰标记        t[rt] +&#x3D; v;    &#x2F;&#x2F;最大值加上v之后，此区间的最大值也肯定是加v    &#125;    else&#123;        Pushdown(k);    &#x2F;&#x2F;重难点，查询lazy标记，更新子树        int m &#x3D; l + ((r-l)&gt;&gt;1);        if(Ld &lt;&#x3D; m)    &#x2F;&#x2F;如果左子树和需要更新的区间交集非空            update(Ld,Rd,v,l,m,rt&lt;&lt;1);        if(m &lt; Rd)    &#x2F;&#x2F;如果右子树和需要更新的区间交集非空            update(Ld,Rd,v,m+1,r,rt&lt;&lt;1|1);        Pushup(rt);    &#x2F;&#x2F;更新父节点    &#125;&#125;&#x2F;&#x2F;递归方式区间查询 query(Ld,Rd,1,n,1);int query(int Ld,int Rd,int l,int r,int rt)&#123;    &#x2F;&#x2F;[L,R]即为要查询的区间，l，r为结点区间，k为结点下标    if(Ld &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; Rd)    &#x2F;&#x2F;如果当前结点的区间真包含于要查询的区间内，则返回结点信息且不需要往下递归        return t[rt];    else&#123;        Pushdown(rt);    &#x2F;**每次都需要更新子树的Lazy标记*&#x2F;        int res &#x3D; -INF;    &#x2F;&#x2F;返回值变量，根据具体线段树查询的什么而自定义        int mid &#x3D; l + ((r-l)&gt;&gt;1);    &#x2F;&#x2F;m则为中间点，左儿子的结点区间为[l,m],右儿子的结点区间为[m+1,r]        if(Ld &lt;&#x3D; m)    &#x2F;&#x2F;如果左子树和需要查询的区间交集非空            res &#x3D; max(res, query(Ld,Rd,l,m,rt&lt;&lt;1));        if(Rd &gt; m)    &#x2F;&#x2F;如果右子树和需要查询的区间交集非空，注意这里不是else if，因为查询区间可能同时和左右区间都有交集            res &#x3D; max(res, query(Ld,Rd,m+1,r,rt&lt;&lt;1|1));        return res;    &#x2F;&#x2F;返回当前结点得到的信息    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font face="微软雅黑" size="4">你我都是内卷背景下不起眼的尘埃，被时代的洪流裹挟向前。</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武汉理工大学《软件工程》复习总括三</title>
      <link href="2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/"/>
      <url>2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/</url>
      
        <content type="html"><![CDATA[<h1>第六章软件结构体系</h1><h2 id="软件结构体系的内容："><a class="header-anchor" href="#软件结构体系的内容：">¶</a><strong>软件结构体系的内容：</strong></h2><p><strong>1、构件</strong>：代表着一组基本的构成要素<br><strong>2、连接件</strong>：也就是构件之间的连接关系<br><strong>3、约束</strong>：是作用于构件或者连接关系上的一些限制条件<br><strong>4、质量</strong>：是系统的质量属性，如性能、可扩展性、可修改性、可重用性、安全性等。<br><strong>5、物理分布</strong>：代表着构件连接之后形成的拓扑结构，描述了软件到硬件之间的影射。</p><h2 id="软件结构体系发展的阶段："><a class="header-anchor" href="#软件结构体系发展的阶段：">¶</a>软件结构体系发展的阶段：</h2><p><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/1.png" alt="在这里插入图片描述"></p><h2 id="体系结构、软件框架、设计模式三者的联系和区别："><a class="header-anchor" href="#体系结构、软件框架、设计模式三者的联系和区别：">¶</a>体系结构、软件框架、设计模式三者的联系和区别：</h2><p><strong>体系结构</strong>：描述某一特定应用领域中系统组织的惯用模式，反映领域中众多系统所共有的结构和语义特性，例如：MVC<br><strong>软件框架</strong>：由开发人员定制的应用系统骨架，整个或部分系统的可重用设计，由一组抽象构件和构件实例之间的交互方式组成。例如Django就是一个开放源代码的应运框架，由Python写成。<br><strong>设计模式</strong>：描述软件系统设计过程中常见问题的一些解决方案，从大量的成功实践中总结出来的，且被广泛公认的实践和知识。<br><strong>软件框架和体系结构的区别及关系：</strong><br><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/2.png" alt="在这里插入图片描述"><br><strong>软件框架和实际模式的区别及关系：</strong><br><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/3.png" alt="在这里插入图片描述"></p><h2 id="软件工程问题中的关键的角色："><a class="header-anchor" href="#软件工程问题中的关键的角色：">¶</a>软件工程问题中的关键的角色：</h2><p><strong>用户</strong>：使用系统实现某种目标<br><strong>软件系统</strong>：待开发的系统<br><strong>环境</strong>：软件系统以外的任何事物</p><h2 id="软件设计的原则（高内聚低耦合）："><a class="header-anchor" href="#软件设计的原则（高内聚低耦合）：">¶</a>软件设计的原则（高内聚低耦合）：</h2><p><strong>内聚性</strong>：是一个模块或子系统内部的依赖程度。分为七种：功能内聚、信息内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、巧合内聚。<br><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/4.png" alt="在这里插入图片描述"><br><strong>耦合性</strong>：是两个模块或者子系统之间依赖关系的强度，程序结构各个模块之间相互关联的度量。模块之间的联系方式一般有7中：非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合、内容耦合。<br><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/5.png" alt="在这里插入图片描述"></p><h2 id="软件体系结构常见的风格："><a class="header-anchor" href="#软件体系结构常见的风格：">¶</a>软件体系结构常见的风格：</h2><p>可以根据文字描述判断出风格的种类即可。<br>**<img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/6.png" alt="在这里插入图片描述"><br><strong>管道/过滤器风格</strong>：把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤的输出是下一个步骤的输入。<br><strong><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/7.png" alt="在这里插入图片描述"><br>主程序—子程序风格</strong>：结构化程序设计的一种典型风格，从功能的观点设计系统，逐步分解和细化，形成整个系统的体系结构。<br><strong><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/8.png" alt="在这里插入图片描述"><br>面向对象风格</strong>：系统被看作是对象的集合，每个对象都有一个它自己的功能集合，数据及作用在数据上的操作被封装成抽象数据类型，只通过接口与外界交互，内部的设计决策则被封装起来。<br>**<img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/9.png" alt="在这里插入图片描述"><br><strong>层次结构风格----客户机／服务器体系结构</strong>：一种分布式系统模型<br><strong>服务器</strong>：为客户机提供服务<br><strong>客户机</strong>：负责与用户的交互       类似于网络编程交互的情景。<br><strong><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/10.png" alt="在这里插入图片描述"><br>层次结构----浏览器/服务器结构</strong>：<br><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/11.png" alt="在这里插入图片描述"><br><strong>层次结构----模型/视图/控制器：（MVC）</strong><br>**<img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/12.png" alt="在这里插入图片描述"><br><strong>基于事件的隐式调用风格</strong>：将应用看成是一个构件集合，每个构件直至发生对它有影响的事件时才有所动作<br>**<img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/13.png" alt="在这里插入图片描述"><br><strong>仓库风格</strong>：以数据为中心，适合于数据由一个模块产生而由其他模块使用的情形<br><img src="/2019/11/05/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-san/14.png" alt="在这里插入图片描述"></p><h1>第七章面向对象设计</h1><h2 id="面向对象的设计和分析中的三种类："><a class="header-anchor" href="#面向对象的设计和分析中的三种类：">¶</a>面向对象的设计和分析中的三种类：</h2><p><strong>1、实体类</strong>：对应系统需求中的每个实体，它们通常需要保存在永久的存储体中，一般使用数据库表和文件来记录，实体类包括存储和传递数据的类，也包括操作数据的类<br><strong>2、控制类</strong>：用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度；<br><strong>3、边界类</strong>：用于对外部用户与系统之间的交互对象进行抽象。主要包括界面类。</p><h2 id="什么是领域模型："><a class="header-anchor" href="#什么是领域模型：">¶</a>什么是领域模型：</h2><p>在面向对象分析和设计的初级阶段，通常先识别出实体类，绘制初始类图，此时的类图称为领域模型，包括实体类和它们之间的相互关系。</p><h1>第八章编写高质量代码</h1><h2 id="程序复杂度怎么计算（重点是第二种，第二种有三种小方法）："><a class="header-anchor" href="#程序复杂度怎么计算（重点是第二种，第二种有三种小方法）：">¶</a>程序复杂度怎么计算（重点是第二种，第二种有三种小方法）：</h2><p><strong>基本思想</strong>：程序复杂性主要取决于程序控制流的复杂性，单一的顺序结构最简单，选择和循环结构构成的环路越多，程序越复杂。<br><strong>实质</strong>：度量程序拓扑结构的复杂性程序图：把程序看成是有一个入口、一个出口的有向图程序图的<br><strong>节点</strong>：每个语句、一个顺序流程的程序代码段、程序流程图中的每个处理符号程序图的<br><strong>有向弧</strong>：程序中的流程控制、程序流程图中连接不同处理符号的、带箭头的线段<br><strong>强连通图(Strongly Connected Graph)</strong>：是指一个有向图（Directed Graph）中任意两点v1、v2间存在v1到v2的路径（path）及v2到v1的路径的图。<br><strong>三种方法</strong>：如果程序图中每个节点都可以由入口节点到达，则<strong>图中环的个数 = 环路复杂度</strong><br>如果程序图是强连通图，则计算环路数V(G)的方法 <strong>方法一：V(G) = e–n + p（e: 弧数，n: 节点数，p: 分离部分的数目,V(G)有向图G中的环数）</strong> <strong>方法二：包括强连通域在内的环路数</strong> <strong>方法三：判定节点数 +  1</strong><br>V(G)与程序复杂性呈正比关系 一般一个模块V(G) ≤ 10</p><h1>第九章测试驱动的实现</h1><h2 id="软件测试的类型："><a class="header-anchor" href="#软件测试的类型：">¶</a><strong>软件测试的类型</strong>：</h2><p>1）从测试对象角度①单元测试 ②集成测试③功能测试 ④性能测试 ⑤安装测试2）测试技术角度①黑盒测试（功能测试）②白盒测试（结构测试）<br>3）是否运行程序角度①静态测试 ②动态测试<br>4）执行测试的方式①手工测试 ②自动化测试</p><h2 id="白盒测试："><a class="header-anchor" href="#白盒测试：">¶</a>白盒测试：</h2><p>在下一次更新中详写。</p><h2 id="自己会设计测试用例：路径覆盖："><a class="header-anchor" href="#自己会设计测试用例：路径覆盖：">¶</a>自己会设计测试用例：路径覆盖：</h2><p>在下一次更新中详写</p><h2 id="软件测试的几个阶段：-每个阶段的名称作用测试的对象"><a class="header-anchor" href="#软件测试的几个阶段：-每个阶段的名称作用测试的对象">¶</a>软件测试的几个阶段：(每个阶段的名称作用测试的对象)</h2><p><strong>1、单元测试</strong>：对软件中的最小可测试单元进行检查和验证 对象是单元。<br><strong>2、集成测试</strong>：在单元测试的基础上，将所有模块按照总体设计的要求组装成为子系统或系统进行的测试 对象是系统或者子系统<br><strong>3、确认测试</strong>：在开发过程中或结束时评估系统或组成部分的过程，目的是判断系统是否满足规定的要求。对象是系统<br><strong>4、系统测试</strong>：检测软件系统运行时与其他相关要素的协调工作情况是否满足要求。对象是系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武汉理工大学《软件工程》复习总括二</title>
      <link href="2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/"/>
      <url>2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/</url>
      
        <content type="html"><![CDATA[<h1>第四章需求获取</h1><p><strong>需求分析的实质</strong>：是对系统的理解与表达的过程，是一种软件工程的活动。</p><p><strong>需求分析之后建立模型的名称</strong>：分析模型或需求模型需求分析的过程：<br><strong>需求分析的过程</strong>：<img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/1.png" alt="在这里插入图片描述"><br><strong>常用的需求分析的方法</strong>：<br>1：面向数据流的结构化分析方法（简称SA）<br>2：面向数据结构的Jackson方法（简称JSD）<br>3：面向对象的分析方法<br>4：建立动态模型的迁移图或Petri网等。<br><strong>软件需求的分类，根据分类的标准不同，结果也不同</strong>：<br><strong>1：按修饰对象的不同</strong>：<br><strong>Ø 产品需求</strong>：<br><strong>l 功能性需求</strong>：软件产品的功能特性<br><strong>l 非功能性需求</strong>：软件产品的质量属性，是在功能性需求满足情况下的进一步要求<br><strong>“FURPS“模型</strong>：<br><strong>功能性</strong>：需要考虑的额外的功能需求，如安全性；<br><strong>可用性</strong>：易用性、美观性、一致性和文档化；<br><strong>可靠性</strong>：指的是在特定操作环境下预期的系统故障频率、可恢复性、可预测性准确性以及平均故障时间；<br><strong>性能</strong>：响应时间、效率、资源利用率和吞吐量（在一个指定时间内系统可完成的工作量）<br><strong>可支持性</strong>：可测试性、适应性、可维护性、兼容性、可配置性、可扩展性和本地化<br><strong>Ø 过程需求</strong>——修饰或限制软件开发过程的要求<br><strong>2：按抽象层次详细程度</strong>：<br><strong>Ø 业务需求</strong><br><strong>Ø 用户需求</strong><br><strong>Ø 系统需求</strong><br><strong>Ø 软件设计规约</strong></p><p><strong>需求优先级的等级：</strong><br><strong>1、基本的</strong>：使得客户能够黑手系统并且必须实现的要求<br><strong>2：可取的</strong>：非常可取但却不是必须的那些需求<br><strong>3：可选的</strong>：在时间和资源允许的情况下，可能会实现的需求<br><strong>4：未来的</strong>：不会在系统当前版本中实现，但考虑到系统后续的版本应该记录下来的需求</p><p><strong>需求获取的技术有哪些</strong>：<br>1：面谈<br>2：问卷调查<br>3：群体诱导技术<br>4：头脑风暴<br>5：参与观察法<br>6：亲身实践<br>7：原型<br>8：情景分析<br>9：概念建模<br>10：A/B测试</p><p><strong>结构化分析的主要工具</strong>：<br>1：数据流图(DFD)<br>2:数据字典(DD)<br>3：结构化语言<br>4：判定树<br>5：判定表</p><p><strong>传统的软件建模中分析模型的核心及围绕核心的三个子模型</strong>：<br>分析模型的核心是数据字典，围绕数据字典3个层次的子模型有数据模型、功能模型和行为模型。<br><strong>数据字典</strong>：用于描述系统软件中使用或者产生的每一个数据元素，是系统数据信息定义的集合。<br><strong>数据模型</strong>：用于描述数据对象之间的关系。其应包含3种相关的信息，即数据对象、属性和关系<br><strong>功能模型</strong>：可以用数据流图描述（数据流图是一种图形化技术，可以表达软件系统必须完成的功能），所以又称数据流模型。<br><strong>行为模型</strong>：常用状态转化图（即状态图）来描述，又称状态机模型，可以理解为，在任一个时刻，系统处于有限可能的状态中的一个状态，当某一个激励条件到达时，它激发系统从一个状态转换到另一新状态。</p><h1>第五章</h1><p><strong>用例建模UML的九种图的画法，以及每种图的作用，在分析和设计的过程中怎么使用：</strong><br><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/2.png" alt="在这里插入图片描述"><br><strong>1、用例图：</strong><br><strong>作用</strong>：表示角色和用例之间的关系，其中用例代表的是一个系统或分类器的功能，外部交互者与这一分类器来进行交互呈现。<br><strong>组成/使用</strong>：由一些角色、一组用例，还可能有一些接口以及这些组成元素之间的关系构成的图，其中关系是指角色和用例之间的联系。用例通常用矩形框起来以表示系统或分类器的边界。<br><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/3.png" alt="在这里插入图片描述"><br><strong>2、类图：</strong><br><strong>作用</strong>：静态描述性模型元素相互连接的集合图，可以表示不同实体（人，事务和数据）的内部构成<br><strong>组成/使用</strong>：名称，属性和方法，他们之间的关系。#表示受保护成员，+表示公有成员，“-”表示私有成员。<br><strong><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/4.png" alt="在这里插入图片描述"><br>3、交互图</strong> ：包括顺序图和协作图，两种图在内容上是等效的，可以相互转换。<br><strong>顺序图</strong>：强调消息的时间排序<br><strong>作用</strong>：表示交互，指为得到一个期望的结果而在多个分类器角色之间进行的交互序列。<br><strong>组成/使用</strong>：顺序图有两维，垂直维代表时间，水平维代表对象。通常，垂直维自上至下代表时间向前推进。<br><strong>协作图</strong>：强调发送消息和接收消息的对象的结构组织<br><strong>作用</strong>：描述相互联系的对象之间的关系，或者分类器角色和关联角色之间的关系以下是同一个例子分别用两种图的表示<br><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/5.png" alt="在这里插入图片描述"> 顺序图<br><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/6.png" alt="在这里插入图片描述"><br>协作图<br><strong>4、状态图</strong>：描述模型元素在接收到事件后的动态行为。<br><strong>作用</strong>：描述一个类的对象在生命周期里如何从一个状态转移到另外一个状态，类的迁移由事件触发。<br><strong>组成/使用</strong>：图形中的状态和各种其他类型的顶点（伪状态）用适当的状态或者伪状态符号表示，状态之间的转换则用有向弧连接表示。<img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/7.png" alt="在这里插入图片描述"></p><p><strong>5、活动图</strong>：是状态图的一种特殊的情况，其中绝大部分状态是动作或子活动状态，并且绝大部分甚至所有的转换是通过动作或者子活动的完成所触发的。<br><strong>作用</strong>：描述绝大多数甚至是所有的事件是由内部动作的完成所引起的情况。<br><strong>组成</strong>：由一条路径组成。包含并发和分叉，并发：两个活动同时发生。  分叉：选择性活动的发生<br><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/8.png" alt="在这里插入图片描述"><br><strong>6、构件图：</strong><br><strong>作用</strong>：表示构建之间的依赖关系组成：软件构建包括源代码构建、二进制代码构建和可执行构建，一些构建存在于编译时刻，一些存在于链接时刻，一些存在于运行时刻，还有一些可能存在于不止一个时刻。<br><strong>组成/使用</strong>：使用箭头表示依赖关系<br><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/9.png" alt="在这里插入图片描述"><br><strong>7、配置图：</strong><br><strong>作用</strong>：表示系统运行时的处理元素、软件构件以及基于它们的进程和对象的配置情况<br><strong>组成/使用</strong>：不处于运行状态的实体的软件构件不出现（在构件图中表示），结点可能包含构件实例，构件可能包含对象，构件与构件之间的依赖关系用箭线表示<br><strong><img src="/2019/11/03/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-er/10.png" alt="在这里插入图片描述"><br>用例之间的关系</strong>：泛化、包含、扩展</p><p><strong>用例的场景：</strong><br>1：某个用例的一个实例，只描述完成给定的用例行为的若干可能途径中的一种  2：一个用例可能存在多个场景<br>3：系统会根据参与者提供的不同信息进入不同的场景<br>4：场景可以表达：正面行为需求，反面行为需求，不希望发生的交互，并行机制</p><p><strong>类与类之间的关系</strong>：<br>1：关联关系：包含自返关联、二元关联、N元关联<br>2：泛化关系<br>3：依赖关系<br>4：实现关系</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武汉理工大学《软件工程》复习总括一</title>
      <link href="2019/11/02/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-yi/"/>
      <url>2019/11/02/wu-han-li-gong-da-xue-ruan-jian-gong-cheng-fu-xi-zong-gua-yi/</url>
      
        <content type="html"><![CDATA[<h1>第一章软件工程概述</h1><p><strong>软件的本质特征：</strong><br>复杂性+一致性+可变性+不可见性<br><strong>软件危机的概念：</strong><br>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列问题。<br><strong>软件工程的概念：</strong><br>1：将系统化的、规范的、可度量的方法应运与软件的开发、运行和维护的过程，即将工程化应运与软件中<br>2：对1中所述的方法的研究<br><strong>软件工程的关键元素</strong>：方法+工具+过程<br><strong>软件工程的开发策略</strong>：软件复用+分而治之+逐步演进+折中优化<br><strong>软件工程的基本原理：</strong><br>1：用分阶段的生命周期计划严格管理<br>2：坚持进行评审阶段<br>3：实行严格的产品控制<br>4：采用现代化程序设计技术<br>5：结果应能清楚的审查<br>6：开发小组人员应少而精<br>7：承认不断改进软件工程的必要性</p><h1>第二章软件过程</h1><p><strong>软件过程的定义及包含的活动：</strong><br>软件过程是指软件生成周期中的一系列相关过程，是为了获得高质量软件而实施的一系列活动。它包括问题定义、需求开发、软件设计、软件构造、软件测试等一系列软件开发的实现活动，而每一项都会产生相应的中间制品。<br><strong>软件过程常见的模型及其关系</strong>：<br>Ø <strong>瀑布模型</strong>——无法适应需求变化，计划驱动<br>特点：①. 阶段间具有顺序性和依赖性，便于分工合作；<br>②. 强调软件文档的重要性，要求每个阶段都进行仔细的验证；<br>③. 文档便于修改，并有复审质量保证。<br>缺陷：①. 划分固定，产生大量文档，增加了开发的工作量；<br>②. 开发是线性的，用户只有在整个程结束时才能看到开发成果；<br>③. 难以响应开发过程中用户的变更需求；<br>④. 早期错误难以发现适用于在软件需求明确，开发技术比较成熟，工程管理较严格的场合下使用（基本不会单独使用瀑布模型作为软件过程模型）<br>Ø <strong>原型化模型</strong>——需求不明确时选用<br>从用户需求出发快速建立一个原型，使用户通过这个原型初步表达出自己的需求，并通过反复修改完善逐渐靠近用户的全部需求，最终形成一个完全满足用户需求的新体系。<br>例：3D打印机<br>Ø <strong>迭代式开发</strong>——适应需求变化<br>开发被组织成一系列固定的短期小项目，称为一次迭代，每次迭代都包括完整的需求分析、设计、实现和测试活动。（理解：发布一系列版本）<br>增量开发：逐渐增加新的功能（缺点：增加功能的过程中可能破坏原有系统）<br>迭代开发：一次性开发出所有功能，后期再逐步完善各个功能<br>优点：①. 快速交付产品；<br>②. 快速响应需求变更；<br>③. 关注用户行为，很快得到用户反馈例：网上视频学习网站<br>Ø <strong>可转换模型</strong>——数学方法（安全、可靠、保密）<br>特点：需要一个精确表述的形式化的规格说明<br>例：汽车防抱系统，嵌入式控制系统<br><strong>关系</strong>：这些模型相互并不排斥，而且经常一起使用，尤其是对一些大型系统的开发。<br><strong>敏捷软件开发的核心价值</strong>：<br>1：“个体和交互”胜过“过程和工具”<br>2：“可以工作的软件”胜过“面面俱到的文档”<br>3：“客户合作”胜过“合同谈判”<br>4：“响应变化”胜过“遵循计划”</p><h1>第三章对象模型</h1><p><strong>面向对象方法的精华</strong>：面向对象=对象+分类+继承+消息通信<br><strong>1：对象</strong>：<br>客观世界都是由各种对象组成，任何事物都是对象，复杂的对象可以由比较简单的对象组合起来<br><strong>2：分类</strong>：<br>把所有的对象都划分为各种类，每个类都定义了一组数据和一组方法<br><strong>3：继承</strong>：<br>按照子类和父类的关系分类组成一个层次结构的系统，下层的子类与上层的父类有相同的特性<br><strong>4：消息通信</strong>：对象与对象之间只能通过传递消息进行通信。<br><strong>接口的概念</strong>：方法声明的集合<br><strong>对象属性和方法的三种访问权限</strong>：<br><strong>1：公有的（public）</strong>：其他对象可以直接访问<br><strong>2：私有的  (private)</strong>：只有特定的对象可以访问<br><strong>3：保护的(protected)</strong>：表示允许相关对象的访问<br><strong>对象的职责</strong>：即一个对象对其他对象的职责<br>1：“知道”型职责:知道各类数据和引用变量<br>2：“做”型职责：执行计算完成某项任务<br>3：“交流”型职责：和其他对象进行交流</p><p>此部分仅为第一到三章的内容，后续部分会依次更新，请您关注我的博客，在我的博客中寻找其他几章内容！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
